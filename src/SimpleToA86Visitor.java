import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTree;

import java.io.FileInputStream;
import java.io.InputStream;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

/**
 * @author  Can Candan cancandan@gmail.com
 *
 * This class extends the SimpleBaseVisitor base class which is generated by the ANTLR using the -visitor option.
 *
 * Given the grammar file, here it is Simple.g4, ANTLR generates the lexer and parser classes and base visitor class
 * with the methods for all the labeled grammar rules (labels are text following #, eg. #whiledo or #begined)
 * What is left to do to create a language application is to walk the parse tree and perform actions
 * necessary for the application to work. Here as I walk the tree I create a86 code.
 *
 */
public class SimpleToA86Visitor extends SimpleBaseVisitor<String> {
    /**
     * As the tree is walked its necessary to keep track of variables.
     * When we see a ID type we check this set, if it is not here, we are dealing with an assigment statement.
     * Otherwise we create code to get the value of the variable.
     */
    public Set variableDefs = new HashSet();

    /**
     * Variable to keep track of labels corresponding to if and while statements.
     */
    public int labelIndex=0;


    @Override
    public String visitProg(SimpleParser.ProgContext ctx) {
        List<SimpleParser.StmContext> stmts= ctx.stm();
        StringBuilder sb = new StringBuilder();
        for (SimpleParser.StmContext stmt:stmts) {
            String ret=visit(stmt);
            sb.append(ret);
        }
        return sb.toString();
    }

    @Override
    public String visitAssign(SimpleParser.AssignContext ctx) {
        String varName = ctx.ID().getText();
        if (!variableDefs.contains(varName))
            variableDefs.add(varName);
        String code= "push offset "+ctx.ID().getText()+"\n";
        code=code+visit(ctx.expr());
        code=code+"pop ax\npop bx\nmov [bx],ax\n";
        return code;
    }

    @Override
    public String visitInt(SimpleParser.IntContext ctx) {
        //return "push "+ctx.getText()+"\n";
        return "mov ax, "+ctx.getText()+"\npush ax\n";
    }

    @Override
    public String visitId(SimpleParser.IdContext ctx) {
        return "push ["+ctx.getText()+"]\n";
    }

    @Override
    public String visitAdd(SimpleParser.AddContext ctx) {
        String code= visit(ctx.expr(0));
        code=code+visit(ctx.expr(1));
        code=code+"pop ax\npop bx\nadd ax,bx\npush ax\n";
        return code;
    }

    @Override
    public String visitMul(SimpleParser.MulContext ctx) {
        String code= visit(ctx.expr(0));
        code=code+visit(ctx.expr(1));
        code=code+"pop ax\npop bx\nmul bx\npush ax\n";
        return code;
    }

    @Override
    public String visitSub(SimpleParser.SubContext ctx) {
        String code= visit(ctx.expr(0));
        code=code+visit(ctx.expr(1));
        code=code+"pop bx\npop ax\nsub ax,bx\npush ax\n";
        return code;
    }

    @Override
    public String visitDiv(SimpleParser.DivContext ctx) {
        String code= visit(ctx.expr(0));
        code=code+visit(ctx.expr(1));
        code=code+"pop bx\npop ax\ncall handlediv\npush ax\n";
        return code;
    }

    @Override
    public String visitMod(SimpleParser.ModContext ctx) {
        String code= visit(ctx.expr(0));
        code=code+visit(ctx.expr(1));
        code=code+"pop bx\npop ax\nxor dx, dx\ndiv bx\npush dx\n";
        return code;
    }

    @Override
    public String visitParens(SimpleParser.ParensContext ctx) {
        return visit(ctx.expr());
    }

    @Override
    public String visitPrint(SimpleParser.PrintContext ctx) {
        String code=visit(ctx.expr());
        code=code+"pop ax\n";
        code=code+"call myprint\n";
        return code;
    }


    /**
     * Generates code according to this template:
     *
     * code for expr
     * pop ax
     * cmp ax,0
     * jz outlabel
     * code for stm
     * outlabel:
     * nop
     * @param ctx
     * @return a86 code for this if statement
     */
    @Override
    public String visitIfthen(SimpleParser.IfthenContext ctx) {
        int currentLabelIndex= labelIndex;
        labelIndex=labelIndex+1;
        String code= visit(ctx.expr());
        code=code+"pop ax\ncmp ax,0\njz outlabel"+String.valueOf(currentLabelIndex)+"\n";
        code=code+visit(ctx.stm());
        code=code+"outlabel"+String.valueOf(currentLabelIndex)+":\nnop\n";
        return code;
    }



    /**
     * Generates code according to this template:
     *
     * whiletestlbl:
     *  nop
     *  code for expr
     *  pop ax
     *  cmp ax,0
     *  jz whilelbl
     *  code for stm
     *  jmp testlabel
     * whilelbl:
     *  nop
     * @param ctx
     * @return a86 code for this while statement
     */
    @Override
    public String visitWhiledo(SimpleParser.WhiledoContext ctx) {
        int currentLabelIndex= labelIndex;
        String ci=String.valueOf(currentLabelIndex);
        labelIndex=labelIndex+1;

        String code= "whiletestlbl"+ci+":\nnop\n";
        code=code+visit(ctx.expr());
        code=code+"pop ax\ncmp ax,0\njz whilelbl"+ci+"\n";
        code=code+visit(ctx.stm());
        code=code+"jmp whiletestlbl"+ci+"\n"+"whilelbl"+ci+":\nnop\n";
        return code;
    }

    @Override
    public String visitBeginend(SimpleParser.BeginendContext ctx) {
        return visit(ctx.opt_stmts());
    }

    @Override
    public String visitOpt_stmts(SimpleParser.Opt_stmtsContext ctx) {
        return visit(ctx.stmt_list());
    }

    @Override
    public String visitStmt_list(SimpleParser.Stmt_listContext ctx) {
        List<SimpleParser.StmContext> stmts= ctx.stm();
        StringBuilder sb = new StringBuilder();
        for (SimpleParser.StmContext stmt:stmts) {
            String ret=visit(stmt);
            sb.append(ret);
        }
        return sb.toString();
    }

}
